# 연습문제
# 6.1 ----------------------------------------------------------------- #
"""
(3) p = p.link
"""
# 6.2 ----------------------------------------------------------------- #
"""
연습 - 6.2.py 참고
1) init 함수에 self.cnt 추가한다.
2) insert 및 delete 시 각각 self.cnt의 값을 하나 더하거나 빼준다.
3) size 함수는 그냥 self.cnt를 return하게 하도록 만들면 된다.
"""
# 6.3 ----------------------------------------------------------------- #
"""
Node(data=D, link=None)를 가리킴.
"""
# 6.4 ----------------------------------------------------------------- #
"""
p = list
while p != None:
    print(p.data, end='')
    p = p.link
"""
# 6.5 ----------------------------------------------------------------- #
"""
▼ 실제 LinkedList에 추가한 함수
def reverseDisplay(self, size, msg=''):
        node = self.head
        for _ in range(size-1):
            node = node.link
        print(msg, node.data, end=' ')
        size -= 1
        if size != 0:
            return self.reverseDisplay(size)
"""
# 6.6 ----------------------------------------------------------------- #
"""
(2) newNode.link = preNode.link
"""
# 6.7 ----------------------------------------------------------------- #
"""
(3) (b)에서 자료 C를 가져오려면 pop 연산이 2회 필요하다.
> 3회 필요함.
"""
# 6.8 ----------------------------------------------------------------- #
"""
(4) deleteLast 연산 : 덱의 마지막 원소를 삭제
> 후단을 삭제하고 나면 rear가 한 칸 앞으로 움직여야 하지만, 
단순연결리스트의 노드에는 선행노드의 정보가 없어서 front부터 시작하여 선행노드를 찾기 위해 전체 노드를 탐색해야 함.
결론적으로 O(n)의 시간이 걸림.
"""
# 6.9 ----------------------------------------------------------------- #
"""
solving...
"""
# 6.10 ----------------------------------------------------------------- #
"""
단순연결리스트 : O(n) / 삭제할 노드를 알고 있다면 그 전 노드인 before을 찾아야 함.
이중연결리스트 : O(1) / 삭제할 노드를 알고 있다면 바로 전 노드에 연결이 되어 있음.
"""
# 6.11 ----------------------------------------------------------------- #
"""
tail을 사용하면 head가 tail.link가 되어 전단과 후단 모두 사용이 편리해진다.
하지만 head를 사용하면 전단은 바로 접근이 가능하지만,
후단으로 가기 위해서 링크를 따라 후속노드 전체를 끝까지 이동해야 하므로 전자가 효율적이다.
"""
# 6.12 ~ 6.17 : 따로 파일을 만들어 풂.