import os, sys
sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))
"""
부모폴더의 절대경로를 참조 path에 추가
https://seongkyun.github.io/others/2019/04/29/python_import/
"""

from Chapter04.Stack import *
from Deque import *
from Queue import *
from PriorityQueue import *


# 연습문제
# 5.1 ----------------------------------------------------------------- #
"""
(1) A, B, C, D, E
"""
# 5.2 ----------------------------------------------------------------- #
"""
40, 50
"""
# 5.3 ----------------------------------------------------------------- #
"""
큐는 LILO/FIFO 방식을 채택므로, 삽입과 삭제가 각각 다른 방향에서 이루어짐. 
선형으로 큐를 구현할 경우 필연적으로 둘 중 하나의 시간복잡도는 O(n)이 됨.
-> 원형 큐를 구현하면 이와 같은 문제점을 해결할 수 있음.
"""
# 5.4 ----------------------------------------------------------------- #
"""
7개
"""
# 5.5 ----------------------------------------------------------------- #
"""
(2) 2
"""
# 5.6 ----------------------------------------------------------------- #
"""
(3) front == rear
"""
# 5.7 ----------------------------------------------------------------- #
"""
(4) front == (rear + 1) % MAX_QSIZE
"""
# 5.8 ----------------------------------------------------------------- #
"""
start >>>  [front : 0, rear : 2] ==>  ['B', 'C']
(1) A 추가 >>> [front : 0, rear : 3] ==>  ['B', 'C', 'A']
(2) D 추가 >>> [front : 0, rear : 4] ==>  ['B', 'C', 'A', 'D']
(3) 삭제 >>> [front : 1, rear : 4] ==>  ['C', 'A', 'D']
(4) E 추가 >>> [front : 1, rear : 0] ==>  ['C', 'A', 'D', 'E']
(5) 삭제 >>> [front : 2, rear : 0] ==>  ['A', 'D', 'E']
"""
# 5.9 ----------------------------------------------------------------- #
"""
(1) enqueue(1) [front : 0, rear : 1] ==>  [1]
(2) enqueue(2) [front : 0, rear : 2] ==>  [1, 2]
(3) enqueue(3) [front : 0, rear : 3] ==>  [1, 2, 3]
(4) dequeue() [front : 1, rear : 3] ==>  [2, 3]
(5) enqueue(4) [front : 1, rear : 4] ==>  [2, 3, 4]
"""
# 5.10 ----------------------------------------------------------------- #
"""
(1) 양쪽 끝에서 추가와 삭제가 가능하다.
(3) 선형 자료구조이다.
"""
# 5.11 ----------------------------------------------------------------- #
"""
(4) deleteFront()
(6) addRear(x)
"""
# 5.12 ----------------------------------------------------------------- #
"""
(3) addFront(x)
(7) deleteRear()
"""
# 5.13 ----------------------------------------------------------------- #
# 1) deleteFront()
"""
def dequeue(self):
    if not self.isEmpty():
        self.front = (self.front+1) % MAX_QSIZE
        return self.items[self.front]
"""
# 2) addFront(x)
"""
def addFront(self, item):
        if not self.isFull():
            self.items[self.front] = item
            self.front = self.front - 1
            if self.front < 0: self.front = MAX_QSIZE - 1
"""
# 5.14 ----------------------------------------------------------------- #
"""
(1) O(1)
"""
# 5.15 ----------------------------------------------------------------- #
"""
[0, 3, 6, 9]
[6, 9, 12, 15, 18]
"""
# 5.16 ----------------------------------------------------------------- #
"""
[front : 4, rear : 0] ==>  [4]
[front : 4, rear : 1] ==>  [4, 8]
[front : 4, rear : 2] ==>  [4, 8, 9]
[front : 3, rear : 2] ==>  [5, 4, 8, 9]
[front : 3, rear : 2] ==>  [5, 4, 8, 9]
[front : 4, rear : 2] ==>  [4, 8, 9]
[front : 4, rear : 1] ==>  [4, 8]
[front : 4, rear : 2] ==>  [4, 8, 7]
[front : 4, rear : 2] ==>  [4, 8, 7]
[front : 4, rear : 2] ==>  [4, 8, 7]
[front : 4, rear : 3] ==>  [4, 8, 7, 6]
[front : 0, rear : 3] ==>  [8, 7, 6]
[front : 1, rear : 3] ==>  [7, 6]
"""
# 5.17 ----------------------------------------------------------------- #
"""
D = CircularDeque()
for i in range(1, 9):
    D.enqueue(i)

Q = CircularQueue()
for _ in D.items:
    Q.enqueue(D.deleteRear())
    
while Q.peek() is not None:
    D.addRear(Q.dequeue())

print("D ---> : ", end=" ")
D.display()
"""
# 5.18 ----------------------------------------------------------------- #
"""
D = CircularDeque()
for i in range(1, 9):
    D.enqueue(i)

S = Stack()
for _ in D.items:
    S.push(D.deleteFront())

while S.size() != 0:
    D.enqueue(S.pop())
    if D.peek() == None:
        D.deleteFront()

print("D ---> ", end='')
D.display()
"""
# 5.19 ----------------------------------------------------------------- #
"""
pq = PriorityQueue()
pq.enqueue(23); pq.enqueue(28); pq.enqueue(39)
pq.enqueue(14); pq.enqueue(55)
for _ in range(5):
    print(pq.dequeue())
"""
# 55 39 28 23 14
# 5.20 ----------------------------------------------------------------- #
"""
우선순위 큐는 들어온 순서와 상관 없이 우선순위가 높은 데이터가 먼저 출력되기 때문.
"""